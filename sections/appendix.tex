\appendix
\chapter{Generic Programming}
\section{Instances Functor for Pattern Functors}
\label{app-inst-functor-patfun}
\begin{minted}{haskell}
instance Functor I where
  fmap f (I r) = I (f r)

instance Functor (K a) where
  fmap _ (K a) = K a

instance Functor U where
  fmap _ U = U

instance (Functor f, Functor g) => Functor (f :+: g) where
  fmap f (L x) = L (fmap f x)
  fmap f (R y) = R (fmap f y)

instance (Functor f, Functor g) => Functor (f :*: g) where
  fmap f (x :*: y) = fmap f x :*: fmap f y
\end{minted}


\chapter{Implementation Memo Cata}
\section{Implementation Merkle}
\label{app-impl-merkle}
\begin{minted}{haskell}


merkle :: (Regular a, Hashable (PF a), Functor (PF a)) 
       => a -> Merkle (PF a)
merkle = In . merkleG . fmap merkle . from
\end{minted}

\section{Implementation Cata Merkle}
\label{app-impl-cata-merkle}
\begin{minted}{haskell}
cataMerkleState :: (Functor f, Traversable f)
                => (f a -> a) -> Fix (f :*: K Digest) 
                -> State (M.Map Digest a) a
cataMerkleState alg (In (x :*: K h)) = do m <- get
  case M.lookup h m of
    Just a -> return a
    Nothing -> do y <- mapM (cataMerkleState alg) x
                  let r = alg y
                  modify (M.insert h r) >> return r

cataMerkle :: (Functor f, Traversable f)
           => (f a -> a) -> Fix (f :*: K Digest) -> (a, M.Map Digest a)
cataMerkle alg t = runState (cataMerkleState alg t) M.empty
\end{minted}

\section{Implementation Zipper Merkle}
\label{app-impl-zipper-merkle}
\begin{minted}{haskell}
data Loc :: * -> * where
  Loc :: (Zipper a) => Merkle a 
                    -> [Ctx (a :*: K Digest) (Merkle a)] 
                    -> Loc (Merkle a)

modify :: (a -> a) -> Loc a -> Loc a
modify f (Loc x cs) = Loc (f x) cs

updateDigest :: Hashable a => Merkle a -> Merkle a
updateDigest (In (x :*: _)) = In (merkleG x)

updateParents :: Hashable a => Loc (Merkle a) -> Loc (Merkle a)
updateParents (Loc x []) = Loc (updateDigest x) []
updateParents (Loc x cs) = updateParents
                          $ expectJust "Exception: Cannot go up"
                          $ up (Loc (updateDigest x) cs)

updateLoc :: Hashable a => (Merkle a -> Merkle a) 
                        -> Loc (Merkle a) -> Loc (Merkle a)
updateLoc f loc = if   top loc'
                  then loc'
                  else updateParents 
                       $ expectJust "Exception: Cannot go up" (up loc')
  where
    loc' = modify f loc
\end{minted}

\chapter{Regular}

\section{Zipper}
\begin{minted}{haskell}
data instance Ctx (K a) r
data instance Ctx U r
data instance Ctx (f :+: g) r = CL (Ctx f r) | CR (Ctx g r)
data instance Ctx (f :*: g) r = C1 (Ctx f r) (g r) | C2 (f r) (Ctx g r)
data instance Ctx I r = CId
data instance Ctx (C c f) r = CC (Ctx f r)
data instance Ctx (S s f) r = CS (Ctx f r)
\end{minted}