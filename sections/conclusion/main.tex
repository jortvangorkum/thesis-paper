\chapter{Conclusion}

We have created an algorithm for incremental computation over recursive datatypes in Haskell. We have shown that the algorithm performs faster than the non-incremental version after $10^3$ nodes. Also, the additional memory usage needed to store the cache for the incremental computation is negligible when correctly tuned. The better performance is accomplished by storing the hashes for equality inside the recursive data structure and using a Zipper to efficiently update the hashes when the data structure changes.

We introduced the pattern synonyms to improve the developer experience to almost the same level as the non-incremental implementation. The pattern synonyms can also be generated using \texttt{TemplateHaskell} to elevate the amount of additional work for the developers.

We define possible cache addition and cache replacement policies to improve the performance/memory usage of the algorithm. There are multiple policies defined to inspire the developers to find the fitting one for their use-case.

However, some difficulties still remain. First, the initial pass of the incremental algorithm is a lot slower than the non-incremental version. Therefore, the algorithm needs to be performed a lot (with small changes), before being overall faster than the non-incremental version. Secondly, finding the correct policies for the best performance can be quite cumbersome. 

\input{sections/conclusion/future_work.tex}