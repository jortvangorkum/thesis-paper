\section{Future Work}

The Thesis paper still has some topics that need further exploring. A few small topics would be: 
\begin{itemize}
  \item Implement a storage medium which does not rehash the key (because the key is already a hash).
  \item Implement a default cache replacement policy which generally works well for all algorithms. 
  \item Implement the generation of the pattern synonyms using \texttt{TemplateHaskell}.
  \item Run the benchmarks in a more stable environment than a laptop.
\end{itemize}

\subsection{Support for Mutually Recursive Datatypes}
The current implementation of the algorithm only supports Regular datatypes. This makes the possible datatypes this algorithm can be used with quite limited. To increase the amount of datatypes, we need to support mutually recursive datatypes. One big advantage of supporting mutually recursive datatypes is that then most AST of popular programming languages can be used with the algorithm. So, for example, we can incrementally calculate the cyclomatic complexity metric over the AST of a programming language.

\subsection{Implement the algorithm using Sums-of-Products}
The generic implementation of the algorithm uses pattern functors. Pattern functors are a simple way to define generic functionality. However, the pattern functors have no restrictions on how they are combined. The Sums-of-Products represents the Haskell datatype better than the pattern functors, by only limiting the creation of sums of products. This can make it easier to implement the generic version of the algorithm or add additional optimizations.

\subsection{Benchmarking with real-world data}
The current results presented in this paper are all synthetic benchmarks. This makes it easier to compare the results and make conclusions. However, it does not represent how well the algorithms actually perform in the real-world. A real-world example would be to compute a metric over public available code\footnote{This does mean that the algorithm needs to support mutually recursive datatypes.}.