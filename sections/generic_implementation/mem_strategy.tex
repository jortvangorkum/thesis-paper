\section{Memory Management}
\todo[inline]{Describe multiple memory strategies for keeping memory usage and execution time low}

\subsection{Cache Addition Policy}

\todo[inline]{Explain and benchmark}

\begin{itemize}
  \item Only add elements that have a certain height.
\end{itemize}

\subsection{Cache Replacement Policies}

Metrics where policies can be based on:
\begin{itemize}
  \item Recency: when added in the HashMap
  \item Frequency: how many times the value is looked up in the HashMap.
  \item Computational cost: how many recursive calls are needed
  \item Iterations: how many iterations the object stays in the HashMap.
\end{itemize}

\todo[inline]{More explaining what to do, no benchmarks}
Best policy is based on use-case. Cannot evaluate for multiple use-cases because it is very use case specific.

Self made-up
\begin{itemize}
  \item Remove the elements that are not used in the computation.
  \item Sort the elements based on the \textbf{amount of hits} times \textbf{the computational cost} (e.g., depth of data structure) and remove the lowest rated elements (could also be done with a probability). Additionally, reduce the amount of hits by one after every computation.
\end{itemize}

Internet
\begin{itemize}
  \item Random Replacement
  \item Queue-based policies
  \item Recency-based policies
  \item Frequency-based policies
  \item RRIP-style policies
\end{itemize}

\todo[inline]{Write about paper selective memoization}