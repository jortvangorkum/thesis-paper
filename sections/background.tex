\section{Background}

\subsection{Regular}
\todo[inline]{Describe the workings of Regular with an example}

\begin{minted}{haskell}
data Tree a = Leaf a
            | Node (Tree a) a (Tree a)

$(deriveAll ''Tree "PFTree")
type instance PF (Tree a) = PFTree a
\end{minted}

\begin{minted}[escapeinside=!!]{haskell}
t :: Tree Int
t = Node (Leaf 1) 2 (Leaf 3)

pt :: Fix (PF (Tree a)) !$\equiv$! Fix (C (K a) :+: C (I :*: K a :*: I))
pt = In (from t)
\end{minted}

\begin{minted}{haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg t = alg (fmap (cata alg) (out t))

cataSum :: Fix (PF (Tree Int)) -> Int
cataSum = cata f
  where
    f :: PF (Tree Int) Int -> Int
    f (L (C (K x)))               = x
    f (R (C (I l :*: K x :*: r))) = l + x + r
\end{minted}

\subsubsection{Zipper}
\begin{minted}{haskell}
data Loc :: * -> * where
  Loc :: (Regular a, Zipper (PF a)) => a -> [Ctx (PF a) a] -> Loc a

data family Ctx (f :: * -> *) :: * -> * 

class Functor f => Zipper f where
  cmap        :: (a -> b) -> Ctx f a -> Ctx f b
  fill        :: Ctx f a -> a -> f a
  first, last :: f a -> Maybe (a, Ctx f a)
  next, prev  :: Ctx f a -> a -> Maybe (a, Ctx f a)
\end{minted}

\begin{minted}{haskell}
-- Move down to the leftmost child. Returns 'Nothing' if the
-- current focus is a leaf.
down :: Loc a -> Maybe (Loc a)
down (Loc x cs) = first (from x) >>= \(a,c) -> return (Loc a (c:cs))
\end{minted}


\subsection{HDiff}
\todo[inline]{Write a piece about what HDiff does and how it suggests the use of Merkle trees}
\todo[inline]{Write a piece about the suggestion of storing the hashes inside a Trie datastructure}

\subsection{Selective Memoization}
\todo[inline]{Write a piece about what to look out for with memoization}