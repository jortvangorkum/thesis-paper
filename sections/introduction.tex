\chapter{Introduction}

\todo[inline]{Write more context}
\todo[inline]{Add a problem statement}
\todo[inline]{Additional optimization by adding the hashes to data structure}
\todo[inline]{Can store the intermediate results compared to memoization}
\todo[inline]{Memory strategies}

\section{Motivation}
Incremental computation is an approach to efficiently update the result by only updating the old output, instead of the recomputing the entire output. A lot of different systems use incremental computation to improve performance, for example, syntax highlighting, parsers, formatting, and spreadsheets. These system take advantage of the fact that results of already performed computations can be reused. A popular technique for reusing results based on input is \textit{memoization}. Memoization works by checking the input of a function has already been computed, if it already has been computed return the result, otherwise compute the result of the function and store it. 

The task of implementing memoization for Haskell is explained in Chapter \ref*{chap-spec-impl}. However, the task, when implementing for multiple datatypes, becomes repetitive and error-prone. To prevent writing memoization implementation for every datatype, we use datatype-generic programming. Datatype-generic programming is a technique that uses the structure of a datatype to define functions for a large class of datatypes, which is explained in more detail in Chapter \ref*{chap-dat-gen-program}. Then, using the Haskell generics library \texttt{regular}, we implement the generic memoization functionality. In Chapter \ref*{chap-gen-impl}, the generic implementation is explained and additionally: complexity, different garbage collection strategies and storage of results. 

To illustrate how the final functionality is going to work, a \textit{default} implementation  and the \textit{generic memoization} implementation of \textbf{max-path-sum} is defined. The \textit{default} implementation traverses through the tree and adds the max value of either side of the node. When the tree gets updated, the entire tree is traversed through to compute the result.

\begin{minted}{haskell}
data BinTree = Leaf Int
             | Node BinTree Int BinTree 
             
exampleTree :: BinTree    
exampleTree = Node (Node (Leaf 8) 7 (Leaf 1)) 3 (Node (Leaf 5) 4 (Leaf 2))

maxPathSum :: BinTree -> Int
maxPathSum (Leaf x)     = x
maxPathSum (Node l x r) = x + max (maxPathSum l, maxPathSum r)

> maxPathSum exampleTree
    18
\end{minted}

The \textit{generic memoization} implementation, first adds hashes of the internal data structure to the data structure (also known as a \textit{merkle tree}). Then, the first computation is performed which gives the result and all the intermediate results. Next, the tree gets updated, in this case the most left leaf (\inlinehaskell{Leaf 8}) is replaced with \inlinehaskell{Leaf 6}. Finally, the updated tree is recomputed reusing the previously computed results. As a result, the complete right side of the root node did not have to be recomputed, because it stayed the same.

\begin{minted}{haskell}
-- Add hashes to data structure
> let merkleTree = merkle exampleTree

-- Initial computation
> let (y, m) = cataMerkle maxPathSum (merkleTree)
    (18, { "6dd": 18, "5df": 15, "fa0": 8, "8d0": 1, "f3b": 9, "84b": 5
         , "1ad": 2 })

-- Update Tree
> let merkleTree' = update (const (merkle (Leaf 6))) [Bttm] merkleTree

-- Incremental computation
> cataMerkleMap maxPathsum m (merkleTree')
    (16, { "6dd": 18, "5df": 15, "fa0": 8, "bbd": 16, "91c": 13, "3af": 6
         , "8d0": 1, "f3b": 9, "84b": 5, "1ad": 2 })
\end{minted}

\section{Contributions}
\begin{itemize}
    \item We define a solution for implementing incremental computation for a single datatype. This solution has a better time complexity than recomputing the entire datatype.
    \item We implement a generic version of the specific solution. This is accomplished by using the \texttt{regular} library.
    \item We compare storing the incremental computations in a HashMap or a Trie.
    \item We show multiple strategies on how to store incremental results and which strategy has the best \textit{time execution/memory} ratio. % Garbage collection/retention rate for items in the map 
\end{itemize}