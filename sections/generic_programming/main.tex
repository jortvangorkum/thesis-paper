\chapter{Datatype-Generic Programming}

The implementation in Chapter \ref{chap-spec-impl} is an efficient implementation for incrementally computing the summation over a \texttt{Tree} datatype. However, when we want to implement this functionality for a different datatype, a lot of code needs to be copied while the process remains the same. This results in poor maintainability, is error-prone and in general just boring.

An example of reducing manual implementations for datatypes is the \textit{deriving} mechanism in Haskell. The built-in classes of Haskell, such as \texttt{Show, Ord, Read}, can be derived for a large class of datatypes. However, deriving is not supported for custom classes. Therefore, we use \textit{Datatype-Generic Programming}\cite*{gibbons2006datatype} to define functionality for a large class of datatypes.

In this chapter, we introduce Datatype-Generic Programming, also known as \textit{generic programming} or \textit{generics} in Haskell, as a technique that allows defining functions which can operate on a large class of datatypes. This prevents the need to write the previously defined functionality for every datatype.

\section{Introduction}
The \texttt{regular} Haskell library is an implementation of generic programming. Here the generic representation of a datatype is called a \textit{pattern functor}. A pattern functor is a stripped-down version of a data type, by only containing the constructor but not the recursive structure. The recursive structure is done explicitly by using a fixed-point operator. 

First, the pattern functors defined in \texttt{regular} are 5 core pattern functors and 2 meta information pattern functors. The core pattern functors describe the datatypes.

\todo[inline]{Introduce generic programming and how it works}
\begin{minted}{haskell}
data U r         = U                     -- Empty constructors
data I r         = I r                   -- Recursive call
data K a r       = K a                   -- Constants
data (:+:) f g r = Inl (f r) | Inr (g r) -- Sums (Choice)
data (:*:) f g r = Pair (f r, g r)       -- Products (Combine)
\end{minted}

The conversion from regular datatypes into pattern functors is done by the \texttt{Regular} type class. The \texttt{Regular} type class has two functions. The \texttt{from} function converts the datatype into a pattern functor and the \texttt{to} function converts the pattern functor back into a datatype. In \texttt{regular}, the pattern functor is represented by a type family. Then using the \texttt{Regular} conversion to a pattern functor, we can write for example the \texttt{Tree} datatype from Chapter \ref{chap-spec-impl} as:

\begin{minted}{haskell}
type family PF a :: * -> *

class Regular a where
    from :: a -> PF a a
    to   :: PF a a -> a

type instance PF (Tree a) = K a                -- Leaf
                         :+: (I :*: K a :*: I) -- Node
\end{minted}

\begin{minted}{haskell}
class GSize f where
    gsize :: (a -> Int) -> f a -> Int
\end{minted}

\begin{minted}{haskell}
instance GSize I where
    gsize f (I x) = f x

instance GSize (K a) where
    gsize _ _ = 0

instance (GSize f, GSize g) => GSize (f :+: g) where
    gsize f (Inl x) = gsize f x
    gsize f (Inr x) = gsize f x

instance (GSize f, GSize g) => GSize (f :*: g) where
    gsize f (Pair (x, y)) = gsize f x + gsize f y
\end{minted}

\begin{minted}{haskell}
size :: (Generic a, GSize (PF a)) => a -> Int
size = 1 + gsize size (from x)
\end{minted}

\question{Maybe remove the results?}

\begin{minted}[escapeinside=!!]{haskell}
t :: Tree Int
t = Node (Leaf 1) 2 (Leaf 3)

pt :: PFTree Int
pt = (Inr (Pair (Pair (I (Inl (K 1)), K 2), I (Inl (K 3)))) 

size t !$\equiv$! 2
\end{minted}

\subsection{Deep vs Shallow recursion}

As described earlier, the \texttt{regular} library uses a fixed-point operator to explicitly define recursion. This is done, by \dots

\begin{minted}{haskell}
data Fix f = In { unFix :: f (Fix f) }
\end{minted}
    
\begin{minted}{haskell}
from' :: (Generic a, Functor (PF a)) => a -> Fix (PF a)
from' = In . fmap from' . from
\end{minted}

\begin{minted}{haskell}
cata :: Functor f => (f a -> a) -> Fix f -> a
cata = f . fmap (cata f) . unFix
\end{minted}

\begin{minted}{haskell}
size' :: (Generic a, GSize (PF a), Functor (PF a), Foldable (PF a)) 
      => a -> Int
size' = cata ((1+) . sum) . from'
\end{minted}

\section{Comparison Generic Libraries}
\subsection{Pattern Functors vs Sums of products}
\todo[inline]{Describe the differences between defining generic data types}

\subsection{Mutually recursive datatypes}
\todo[inline]{Describe what mutually recursive datatypes are and why do we need to know about it}