\section{Sums of Products}
A different way of describing datatypes in a generic representation, besides pattern functors, are \textit{Sums of Products}\cite{vries2014sums} (SOP). SOP is a generic representation with additional constraints compared to pattern functors, which more faithfully reflects the Haskell datatypes: each datatype is a single n-ary sum, where each component of the sum is a single n-ary product. The SOP universe is described using \textit{codes} of kind \texttt{[[*]]}. The outer list describes an n-ary sum, representing the choice between constructors and each inner list an n-ary products, representing the constructor arguments.  The code of kind \inlinehaskell{[[*]]} can then be interpreted to describe Haskell datatypes of kind \inlinehaskell{*}. To define a code, the tick mark \inlinehaskell{`} is used to lift the list to a type-level. 

\begin{minted}{haskell}
Code (Tree a) = `[`[a], `[Tree a, a, Tree a]]
\end{minted}

The usage of SOP has a positive effect on expressing generic functions easily or at all. Additionally, the SOP completely divides the structural representation from the metadata. As a result, you do not have to deal with metadata while writing generic functions. 

However, SOP uses type-level lists to put additional constraints onto the generic representation, while pattern functors does not. This makes extending the generic functionality more complex for SOP than pattern functors, because besides data-level programming, also the type-level programming has to be correct.