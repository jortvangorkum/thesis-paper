\section{Sums of Products}
A different way of describing datatypes in a generic representation, besides pattern functors, are \textit{Sums of Products}\cite{vries2014sums} (SOP). SOP is a generic representation with additional constraints compared to pattern functors, which more faithfully reflects the Haskell datatypes. Each datatype is a single n-ary sum, where each component of the sum is a single n-ary product. In SOP, first the generic representation is first described as a \textit{code} of kind \inlinehaskell{[[*]]}. The outer list describes an n-ary sum, representing the choice between constructors and each inner list an n-ary products, representing the constructor arguments. The code is not the same as the generic representation, the code is the structure which the generic representation has to satisfy. Therefore, a mapping is needed which converts the code of kind \inlinehaskell{[[*]]} into a generic representation of kind \inlinehaskell{*}. The code is defined using a tick mark \inlinehaskell{`} and is used to lift the list from a data-level to a type-level. 

\begin{minted}{haskell}
Code (Tree a) = `[`[a], `[Tree a, a, Tree a]]
\end{minted}

The usage of SOP has a positive effect on expressing generic functions easily or at all. Additionally, the SOP completely divides the structural representation from the metadata. As a result, you do not have to deal with metadata while writing generic functions. 

However, SOP uses type-level lists to put additional constraints onto the generic representation, while pattern functors does not. This makes extending the generic functionality more complex for SOP than pattern functors, because besides data-level programming, also the type-level programming has to be correct.